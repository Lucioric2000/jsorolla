<!--
  ~ Copyright 2015-2016 OpenCB
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~     http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<!DOCTYPE html>

<html lang="en">
<head>

    <meta charset="utf-8">
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- This is configured below in the onLoad() function -->
    <title></title>
</head>

<body>
<script type="module">
    import family from "./resources/family1.js";

    let individualsPool = JSON.parse(JSON.stringify(family));

    //shuffle the pool as a first check to make sure there are no bug depending on the input order
    individualsPool.sort(() => .5 - Math.random());

    console.log(individualsPool)

    function getNode(id) {
        return family.find( i => i.id === id)
    }

    function getParents(node) {
        return node.father.id && node.mother.id ? [node.father.id, node.mother.id] : null
    }

    function getChildren(node) {
        const role = node.sex === "MALE"? "father" : "mother";
        return family.filter( i => i[role].id === node.id)
    }

    function getPartners(node) {
        const children = getChildren(node);
        const partnerRole = node.sex === "MALE"? "mother" : "father";
        const partners = [...new Set(children.map( i => i[partnerRole].id).filter(Boolean))] //filter(Boolean) filters out undefined values: in case of `node` has children with unknown partner
        if (partners.length > 1) console.warn(node.id, "has more than 1 partner!", partners);
        return partners.map(getNode);
    }

    /*function getLevel(id) {
        for (let row = 0; x < DATA.length; row++ ) {
            for (let col = 0; col < row.length; col++ ) {
                if (id === DATA[row][col]) return row;
            }
        } console.error("node level not found");
    }*/


    function hasParentInPool(node, array) {
        const [father, mother] = [array.find( i => i.id === node.father.id), array.find( i => i.id === node.mother.id)];
        return father || mother;
    }

    function removeNodes(ids, array) {
        return array.filter( el => !ids.includes(el.id));
    }

    function sortBySexAndAge(array) {
        return [...array].sort( (a,b) => {
            if (a.sex === "MALE" && b.sex === "MALE") {
                //older first
                return b.age - a.age;
            }
            // MALE first and then FEMALE (on sex string length)
            return a.sex.length - b.sex.length;
        });
    }

    function sortByAge(array) {
        //older first
        return [...array].sort((a,b) => b.age - a.age);
    }

    function sortByPartner(array) {
        return [...array].sort((a,b) => {
            if (a.id === b?.partner?.id) {
                return a.sex === "MALE" ? -1 : 1;
            }
        });
    }

    //TODO re-evaluate this fn
    function sortChildren(array) {
        let parents = array.map(n => getParents(n)).filter(Boolean)

        if (!parents.length) return array; // root generation
        // TODO sort array by same parent
        // TODO NOTE not both parents are necessarily in the previous generation!
        console.log(parents.flat())
        return array
    }

    function sortRootGeneration(array) {
        let unsorted = [...array];
        let sorted = [];
        while(unsorted.length) {
            const node = unsorted[0];
            // add to sorted array the node `node` and its partners, sorted by Sex and then Age
            sorted.push(...sortBySexAndAge([node, ...getPartners(node)]));
            // remove the nodes from the unsorted pool
            unsorted = removeNodes([node, ...getPartners(node)].map( node => node.id), unsorted);
        }
        return sorted;
    }

    let generations = []; //init root level
    let generationCnt = 0;

    // sortRootGeneration() sorts by the root generation criterion only (older-male first).
    // We preprocess the whole pool to make sure the root generation nodes are at the first positions, and they are already sorted.
    individualsPool = sortRootGeneration(individualsPool);

    //console.log("sortGeneration", individualsPool)

    while (individualsPool.length) {
        //console.log("generationCnt", generationCnt)
        let generationNodes = [];
        for (let i = 0; i < individualsPool.length; i++ ){
            const node = individualsPool[i];
            const partners = getPartners(node); //NOTE getPartners() search in the original family, not in the pool.
            const hasSomePartnerInPool = partners.some( n => hasParentInPool(n, individualsPool))
            if (!hasParentInPool(node, individualsPool) && (!partners.length || !hasSomePartnerInPool)) {
                generationNodes.push({
                    ...node,
                    partners: partners.map( p => ({id: p.id})),
                    children: sortByAge(getChildren(node))
                });
            }
        }
        generations[generationCnt] = {
            id: generationCnt,
            individuals: generationNodes // TODO sort by children criterion (=> the position of the parents in the previous generations, and then by age DESC)
        };
        generationCnt++;
        individualsPool = removeNodes(generationNodes.map(_ => _.id), individualsPool);
    }

    console.log(generations)

</script>


</body>
</html>
