<!--
  ~ Copyright 2015-2016 OpenCB
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~     http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<!DOCTYPE html>

<html lang="en">
<head>

    <meta charset="utf-8">
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- This is configured below in the onLoad() function -->
    <title></title>
</head>

<body>
<script type="module">
    import family from "./resources/family1.js";

    let individualsPool = JSON.parse(JSON.stringify(family));

    //shuffle the pool as a first check to make sure there are no bug depending on the input order
    individualsPool.sort(() => .5 - Math.random());

    console.log(individualsPool)

    function getNode(id) {
        return family.find( i => i.id === id)
    }

    function getParents(node) {
        return node.father.id || node.mother.id ? [node.father.id, node.mother.id] : null
    }

    function getChildren(node) {
        const role = node.sex === "MALE"? "father" : "mother";
        return family.filter( i => i[role].id === node.id)
    }

    function getPartners(node) {
        const children = getChildren(node);
        const partnerRole = node.sex === "MALE"? "mother" : "father";
        const partners = [...new Set(children.map( i => i[partnerRole].id).filter(Boolean))] //filter(Boolean) filters out undefined values: in case of `node` has children with unknown partner
        if (partners.length > 1) console.warn(node.id, "has more than 1 partner!", partners);
        return partners.map(getNode);
    }

    function hasParents(node) {
        return node.father.id && node.mother.id
    }

    function hasParentsInPool(node, array) {
        const [father, mother] = [array.find( i => i.id === node.father.id), array.find( i => i.id === node.mother.id)];
        return father || mother;
    }


    function insertNode(element, index, array) {
        // NOTE this works fine in corner cases too (meaning in case of index > array.length).
        return [...array.slice(0, index), element, ...array.slice(index)];
    }

    function removeNodes(ids, array) {
        return array.filter( el => !ids.includes(el.id));
    }

    function im_sort(array, fn) {
        return [...array].sort(fn);
    }

    function sortBySexAndAge(array) {
        return [...array].sort( (a,b) => {
            if (a.sex === "MALE" && b.sex === "MALE") {
                //older first
                return b.age - a.age;
            }
            // MALE first and then FEMALE (on sex string length)
            return a.sex.length - b.sex.length;
        });
    }

    function sortByAge(array) {
        //older first
        return [...array].sort((a,b) => b.age - a.age);
    }

    function sortByPartner(array) {
        return [...array].sort((a,b) => {
            if (a.id === b?.partner?.id) {
                return a.sex === "MALE" ? -1 : 1;
            }
        });
    }

    /**
     * Counts the parents in common between the nodes a and b
     * @param a
     * @param b
     * @return The number of common parents
     */
    function haveSameParents(a, b) {
        //console.log([...new Set(getParents(a))], [...new Set(getParents(b))])
        const parentsA = getParents(a).filter(Boolean);
        const parentsB = getParents(b).filter(Boolean);
        const commonParents = parentsA.filter( n => ~parentsB.indexOf(n))
        return commonParents.length
    }

    /**
     * Sort the array taking into account the order of the nodes in the previous generation.
     * It keeps consistent the order of the parents against their children.
     * It also move orphan nodes close to their first partner.
     * @param {Array} array
     * @param {Array} previousGeneration List of nodes in the previous generation
     * @return {Array} sorted
     */
    function sortChildren(array, previousGeneration) {
        if (!previousGeneration) return array; // root generation

        // criteria
        // - node with same parents close to each other
        // - partners close to each other
        // - node with common parents
        // - node with 1 parent in common
        // - age?

        // TODO NOTE not both parents are necessarily in the previous generation!

        // this is the children list taken from the previous generation.
        // It is flatten to replicate the order of the previous generation (the parents) to the current generation (the children).
        let childs = [...new Set(previousGeneration.individuals.flatMap( ind => ind.children.map(_ => _.id)))]

        //1. sort by same parents
        let sorted = [...array].sort((a, b) => {
            let aPos = childs.indexOf( a.id);
            let bPos = childs.indexOf( b.id);
            if (aPos > 0 && bPos === -1) return -1;
            if (aPos === -1 && bPos > 0) return 1;
            if (aPos === -1 && bPos === -1) return 1;
            return aPos - bPos;
        });

        // 2. move partners close to each other
        let res = [];
        // NOTE it mutates `sorted` array while iterating over it.
        sorted.forEach(node => {
            let partners = getPartners(node)
            if (!hasParents(node) && partners.length) {
                // moving the orphan node after its FIRST partner
                let partnerIndex = sorted.findIndex(ind => ind.id === partners[0].id)
                //console.log(node, partnerIndex)
                sorted = removeNodes(node.id, sorted);
                sorted = insertNode(node, partnerIndex + 1, sorted);
            }
        });

        return sorted;
    }


    /**
     * Sort the array by partner (partners close to each other), then sex (male first) then age (older first)
     * @param {Array} array
     * @return {Array} sorted
     */
    function sortRootGeneration(array) {
        // criteria
        // 1. partners close to each other
        // 2. sort by sex
        // 3. sort by age
        let unsorted = sortByAge(array); // to make sure the first selected is the oldest here `const node = unsorted[0]`
        let sorted = [];
        while(unsorted.length) {
            const node = unsorted[0];
            // add to sorted array the node `node` and its partners, sorted by Sex and then Age
            sorted.push(...sortBySexAndAge([node, ...getPartners(node)]));
            // remove the nodes from the unsorted pool
            unsorted = removeNodes([node, ...getPartners(node)].map( node => node.id), unsorted);
        }
        return sorted;
    }


    /**
     * The following code builds the final data-structure.
    *  The algorithm follow a simple rule to split the nodes in generations:
    *  a node is in the root generation iff it and its partners have't parents.
    *  If we use a pool of individuals in which we delete nodes as soon as we add them in the final structure,
    *  the rule is valid for all generations.
    **/
    let generations = []; //init root level
    let generationCnt = 0;

    // sortRootGeneration() sorts by the root generation criterion only (older-male first).
    // We here preprocess the whole pool to make sure the root generation nodes are at the first positions, and they are already sorted.
    // This is also useful for the sorting of the subsequent generations, partners must be close to each other in any case.
    individualsPool = sortRootGeneration(individualsPool);

    while (individualsPool.length) {
        //console.log("generationCnt", generationCnt)
        let generationNodes = [];
        for (let i = 0; i < individualsPool.length; i++ ){
            const node = individualsPool[i];
            const partners = getPartners(node); //NOTE getPartners() search in the original family, not in the pool.
            const hasSomePartnerInPool = partners.some( n => hasParentsInPool(n, individualsPool))
            if (!hasParentsInPool(node, individualsPool) && (!partners.length || !hasSomePartnerInPool)) {
                generationNodes.push({
                    ...node,
                    partners: partners.map( p => ({id: p.id})),
                    children: sortByAge(getChildren(node))
                });
            }
        }
        generations[generationCnt] = {
            id: generationCnt,
            individuals: sortChildren(generationNodes, generations[generationCnt-1]) // TODO sort by children criterion (=> the position of the parents in the previous generations, and then by age DESC)
        };
        generationCnt++;
        individualsPool = removeNodes(generationNodes.map(_ => _.id), individualsPool);
        //if (generationCnt == 2) break
    }

    console.log(generations)
</script>


</body>
</html>
