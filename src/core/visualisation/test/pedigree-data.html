<!--
  ~ Copyright 2015-2016 OpenCB
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~     http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<!DOCTYPE html>

<html lang="en">
<head>

    <meta charset="utf-8">
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- This is configured below in the onLoad() function -->
    <title></title>
</head>

<body>
<script type="module">
    import family from "./resources/familyData.js";

    let individualsPool = JSON.parse(JSON.stringify(family));
    console.log(family)

    function getNode(id) {
        return family.find( i => i.id === id)
    }

    function getParents(node) {
        return node.father.id && node.mother.id ? [node.father.id, node.mother.id] : null
    }

    function getChildren(node) {
        const role = node.sex === "MALE"? "father" : "mother";
        return family.filter( i => i[role].id === node.id)
    }

    function getPartners(node) {
        const children = getChildren(node);
        const partnerRole = node.sex === "MALE"? "mother" : "father";
        const partners = [...new Set(children.map( i => i[partnerRole].id))]
        if (partners.length > 1) console.error("More than 1 partner!");
        return getNode(partners[0]); //TODO at the moment we support just 1 partner at a time. Be responsible.
    }

    /*function getLevel(id) {
        for (let row = 0; x < DATA.length; row++ ) {
            for (let col = 0; col < row.length; col++ ) {
                if (id === DATA[row][col]) return row;
            }
        } console.error("node level not found");
    }*/


    function hasParentInPool(node, array) {
        const [father, mother] = [array.find( i => i.id === node.father.id), array.find( i => i.id === node.mother.id)];
        return father && mother;
    }

    function removeNodes(ids, array) {
        return array.filter( el => !ids.includes(el.id));
    }

    function sortGeneration(array) {
        // TODO DONE partners must be close to each other
        // TODO sort within children ( haveSameParent(a,b) function ).
        // TODO sort within children in case some of them have partners
        return [...array].sort( (a, b) => {
            console.log(a.id, b.id, a?.partner?.id, b?.partner?.id)
            if (a.id === b?.partner?.id) {
                return a.sex === "MALE" ? -1 : 1;
            }
            return a.id - b.id
        })
    }

    let generations = []; //init root level
    let generationCnt = 0;
    while (individualsPool.length) {
        let generationNodes = [];
        for (let i = 0; i < individualsPool.length; i++ ){
            const node = individualsPool[i];
            const partner = getPartners(node); //NOTE getPartners() search in the original family, not in the pool. At the moment we use just the first partner
            if (!hasParentInPool(node, individualsPool) && (!partner || (partner && !hasParentInPool(partner, individualsPool)))) {
                generationNodes.push({
                    ...node,
                    partner: {id: partner?.id},
                    children: getChildren(node)
                });
            }
        }
        generations[generationCnt] = {
            id: generationCnt,
            individuals: sortGeneration(generationNodes)
        };
        generationCnt++;
        individualsPool = removeNodes(generationNodes.map(_ => _.id), individualsPool);
    }

    console.log(generations)

</script>


</body>
</html>
