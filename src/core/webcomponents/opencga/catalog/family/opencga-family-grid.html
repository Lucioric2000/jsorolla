<!--
  ~ Copyright 2015-2016 OpenCB
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~     http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<link rel="import" href="../../../commons/opencb-grid-toolbar.html">

<dom-module id="opencga-family-grid">
    <template>
        <style include="jso-styles">
            .detail-view :hover {
                background-color: white;
            }

            .detail-view-row :hover {
                background-color: #f5f5f5;
            }

            .cursor-pointer {
                cursor: pointer;
            }

            .members-link-dropdown:hover .dropdown-menu {
                display: block;
            }

            .phenotypes-link-dropdown:hover .dropdown-menu {
                display: block;
            }
        </style>

        <opencb-grid-toolbar from="{{from}}" to="{{to}}" num-total-results-text="{{numTotalResultsText}}"
                             config="{{toolbarConfig}}" on-columnchange="onColumnChange"></opencb-grid-toolbar>

        <div id="{{prefix}}GridTableDiv" style="margin-top: 10px">
            <table id="{{prefix}}FamilyBrowserGrid">
                <thead style="background-color: #eee"></thead>
            </table>
        </div>
    </template>

    <script>
        class OpencgaFamilyGrid extends Polymer.Element {

            constructor() {
                super();

                this.prefix = "VarFamilyGrid" + Utils.randomString(6);
            }

            static get is() {
                return 'opencga-family-grid';
            }

            static get properties() {
                return {
                    opencgaSession: {
                        type: Object
                    },
                    families: {
                        type: Array
                    },
                    search: {
                        type: Object
                    },
                    active: {
                        type: Boolean,
                        value: false
                    },
                    config: {
                        type: Object
                    }
                }
            }

            static get observers() {
                return ['propertyObserver(opencgaSession, search, config, active)'];
            }

            _attachDom(dom) {
                this.appendChild(dom);
            }

            connectedCallback() {
                super.connectedCallback();

                this.renderTable(this.active);
            }

            propertyObserver(opencgaSession, search, config, active) {
                // With each property change we must updated config and create the columns again. No extra checks are needed.
                this._config = Object.assign(this.getDefaultConfig(), this.config);
                this._columns = this._initTableColumns();

                // Config for the grid toolbar
                this.toolbarConfig = {
                    columns: this._columns[0]
                };

                this.renderTable(active);
            }

            renderTable(active) {
                if (!active) {
                    return;
                }

                this.opencgaClient = this.opencgaSession.opencgaClient;

                this.set('families', []);

                let filters = Object.assign({}, this.search);

                // Initialise the counters
                this.from = 1;
                this.to = this._config.pageSize;

                if (UtilsNew.isNotUndefined(this.opencgaClient) && UtilsNew.isNotUndefined(this.opencgaSession.study)
                    && UtilsNew.isNotUndefined(this.opencgaSession.study.fqn)) {

                    filters.study = this.opencgaSession.study.fqn;
                    if (UtilsNew.isNotUndefinedOrNull(this.lastFilters)
                        && JSON.stringify(this.lastFilters) === JSON.stringify(filters)) {
                        // Abort destroying and creating again the grid. The filters have not changed
                        return;
                    }
                    // Store the current filters
                    this.lastFilters = Object.assign({}, filters);

                    // Make a copy of the families (if they exist), we will use this private copy until it is assigned to this.families
                    if (UtilsNew.isNotUndefined(this.families)) {
                        this._families = this.families;
                    } else {
                        this._families = [];
                    }

                    // Check that HTTP protocol is present and complete the URL
                    let opencgaHostUrl = this.opencgaClient.getConfig().host;
                    if (!opencgaHostUrl.startsWith("http://") && !opencgaHostUrl.startsWith("https://")) {
                        opencgaHostUrl = 'http://' + opencgaHostUrl;
                    }
                    opencgaHostUrl += '/webservices/rest/v1/families/search';

                    let skipCount = false;

                    let _table = $('#' + this.prefix + 'FamilyBrowserGrid');

                    let _this = this;
                    $("#" + this.prefix + 'FamilyBrowserGrid').bootstrapTable('destroy');
                    $("#" + this.prefix + 'FamilyBrowserGrid').bootstrapTable({
                        url: opencgaHostUrl,
                        columns: _this._columns,
                        method: 'get',
                        sidePagination: 'server',
                        uniqueId: "id",

                        // Table properties
                        pagination: _this._config.pagination,
                        pageSize: _this._config.pageSize,
                        pageList: _this._config.pageList,
                        showExport: _this._config.showExport,
                        detailView: _this._config.detailView,
                        detailFormatter: _this._config.detailFormatter,

                        // Make Polymer components avalaible to table formatters
                        gridContext: _this,

                        queryParams: function (params) {
                            if (this.pageNumber > 1) {
                                skipCount = true;
                            }

                            let auxParams = {
                                sid: Cookies.get(_this.opencgaClient.getConfig().cookieSessionId),
                                order: params.order,
                                sort: params.sort,
                                limit: params.limit,
                                skip: params.offset,
                                // includeFamily: true,
                                skipCount: skipCount,
                                // include: "id,creationDate,status,uuid,version,release,modificationDate,phenotypes,members,expectedSize"
                            };

                            if (UtilsNew.isUndefined(filters)) {
                                filters = {};
                            }
                            return Object.assign({}, filters, auxParams);
                        },
                        responseHandler: function (response) {
                            if (!skipCount) {
                                if (!_this.hasOwnProperty("numTotalResults")) {
                                    _this.numTotalResults = 0;
                                }
                                if (_this.numTotalResults !== response.response[0].numTotalResults
                                    && response.queryOptions.skip === 0) {
                                    _this.numTotalResults = response.response[0].numTotalResults;
                                }
                            }

                            // Set the num total rows in a human readable format
                            _this.numTotalResultsText = _this.numTotalResults.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");

                            if(response.queryOptions.skip === 0 && _this.numTotalResults < response.queryOptions.limit){
                                _this.from = 1;
                                _this.to = _this.numTotalResults;
                            }

                            return {
                                total: _this.numTotalResults,
                                rows: response.response[0].result
                            };
                        },
                        onClickRow: function (row, element, field) {
                            if (_this._config.multiSelection) {
                                // Check and uncheck when clicking in the checkbox TD cell
                                if (field === "state") {
                                    let index = element[0].dataset.index;
                                    if (element[0].className.includes("selected")) {
                                        $(PolymerUtils.getElementById(_this.prefix + 'FamilyBrowserGrid')).bootstrapTable('uncheck', index);
                                    } else {
                                        $(PolymerUtils.getElementById(_this.prefix + "FamilyBrowserGrid")).bootstrapTable('check', index);

                                        $('.success').removeClass('success');
                                        $(element).addClass('success');
                                    }
                                } else {
                                    // If user has clicked in the row
                                    let index = element[0].dataset.index;
                                    if (element[0].className.includes("selected")) {
                                        $(PolymerUtils.getElementById(_this.prefix + 'FamilyBrowserGrid')).bootstrapTable('uncheck', index);
                                        $(element).removeClass('success');
                                    } else {
                                        $(PolymerUtils.getElementById(_this.prefix + "FamilyBrowserGrid")).bootstrapTable('check', index);
                                    }
                                }
                            } else {
                                // If not checkboxes exist
                                $('.success').removeClass('success');
                                $(element).addClass('success');
                            }

                            _this._onSelectFamily(row);
                        },
                        onDblClickRow: function (row, element, field) {
                            // We detail view is active we expand the row automatically.
                            // FIXME: Note that we use a CSS class way of knowing if the row is expand or collapse, this is not ideal but works.
                            if (_this._config.detailView) {
                                if (element[0].innerHTML.includes("icon-plus")) {
                                    $(PolymerUtils.getElementById(_this.prefix + 'FamilyBrowserGrid')).bootstrapTable('expandRow', element[0].dataset.index);
                                } else {
                                    $(PolymerUtils.getElementById(_this.prefix + 'FamilyBrowserGrid')).bootstrapTable('collapseRow', element[0].dataset.index);
                                }
                            }
                        },
                        onCheck: function (row, element) {
                            // check family is not already selected
                            for (let i in _this._families) {
                                if (_this._families[i].id === row.id) {
                                    return;
                                }
                            }

                            // we add families to selected families
                            _this.push("_families", row);
                            _this.set('families', _this._families.slice());

                            // We only activate the row when checking
                            if (_this._config.detailView) {
                                $('.success').removeClass('success');
                            }
                            $(element[0].parentElement.parentElement).addClass('success');

                            // If exist on single nested sample we must check it
                            if (row.members.length === 1) {
                                let checkbox = PolymerUtils.getElementById(_this.prefix + row.members[0].id + "Checkbox");
                                if (UtilsNew.isNotUndefinedOrNull(checkbox)) {
                                    checkbox.checked = true;
                                }
                            }
                        },
                        onUncheck: function (row, elem) {
                            let familyToDeleteIdx = -1;
                            for (let i in _this.families) {
                                if (_this.families[i].id === row.id) {
                                    familyToDeleteIdx = i;
                                    break;
                                }
                            }

                            if (familyToDeleteIdx === -1) {
                                return;
                            }

                            _this.splice('_families', familyToDeleteIdx, 1);
                            _this.set('families', _this._families.slice());

                            // We detail view is active we expand the row automatically
                            if (_this._config.detailView) {
                                $(PolymerUtils.getElementById(_this.prefix + 'FamilyBrowserGrid')).bootstrapTable('collapseRow', elem[0].dataset.index);
                            }

                            // We must uncheck nested checked samples
                            if (row.members.length > 0) {
                                for (let sample of row.members) {
                                    let checkbox = PolymerUtils.getElementById(_this.prefix + sample.id + "Checkbox");
                                    if (UtilsNew.isNotUndefinedOrNull(checkbox)) {
                                        checkbox.checked = false;
                                    }
                                }
                            }
                        },
                        onCheckAll: function (rows) {
                            let newFamilies = _this._families.slice();
                            // check family is not already selected
                            rows.forEach((family) => {
                                let existsNewSelected = _this._families.some((familySelected) => {
                                    return familySelected.id === family.id;
                                });

                                if(!existsNewSelected) {
                                    newFamilies.push(family);
                                }
                            });

                            // we add families to selected families
                            _this._families = newFamilies;
                            _this.set('families', newFamilies.slice());

                            // We must uncheck nested checked samples
                            for (let row of rows) {
                                if (row.members.length === 1) {
                                    let checkbox = PolymerUtils.getElementById(_this.prefix + row.members[0].id + "Checkbox");
                                    if (UtilsNew.isNotUndefinedOrNull(checkbox)) {
                                        checkbox.checked = true;
                                    }
                                }
                            }
                        },
                        onUncheckAll: function (rows) {
                            // check family is not already selected
                            rows.forEach((family) => {
                                _this._families = _this._families.filter((familySelected) => {
                                    return familySelected.id !== family.id;
                                });
                            });

                            // we add families to selected families
//                            _this.push("_families", row);
                            _this.set('families', _this._families.slice());

                            // We must uncheck nested checked samples
                            for (let row of rows) {
                                for (let sample of row.members) {
                                    let checkbox = PolymerUtils.getElementById(_this.prefix + sample.id + "Checkbox");
                                    if (UtilsNew.isNotUndefinedOrNull(checkbox)) {
                                        checkbox.checked = false;
                                    }
                                }
                            }
                        },
                        onLoadSuccess: function (data) {
                            // Check all already selected rows. Selected families are stored in this.families array
                            if (UtilsNew.isNotUndefinedOrNull(_table)) {
                                if (_this._config.detailView) {
                                    PolymerUtils.querySelector(_table.selector).rows[1].setAttribute('class', 'success');
                                    _this._onSelectFamily(data.rows[0]);
                                }

                                if (_this.families !== "undefined") {
                                    for (let idx in _this.families) {
                                        for (let j in data.rows) {
                                            if (_this.families[idx].id === data.rows[j].id) {
                                                $(PolymerUtils.getElementById(_this.prefix + 'FamilyBrowserGrid')).bootstrapTable('check', j);
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        onPageChange: function (page, size) {
                            _this.from = (page - 1) * size + 1;
                            _this.to = page * size;
                        },
                    });
                } else {
                    // Delete table
                    $(PolymerUtils.getElementById(this.prefix + 'FamilyBrowserGrid')).bootstrapTable('destroy');
                    this.numTotalResults = 0;
                }
            }

            _onSelectFamily(row) {
                if (typeof row !== "undefined") {
                    this.dispatchEvent(new CustomEvent('selectfamily', {
                        detail: {
                            id: row.id,
                            family: row
                        }
                    }));
                }
            }

            onColumnChange(e) {
                let table = $('#' + this.prefix + 'FamilyBrowserGrid');
                if (e.detail.selected) {
                    table.bootstrapTable("showColumn", e.detail.id);
                } else {
                    table.bootstrapTable("hideColumn", e.detail.id);
                }
            }


            detailFormatter(value, row) {
                let result = `<div class='row' style="padding: 5px 10px 15px 10px">
                                <div class='col-md-12'>
                                    <h5 style="font-weight: bold">Members</h5>
                `;

                if (UtilsNew.isNotEmptyArray(row.members)) {
                    let tableCheckboxHeader = "";

                    if (this.gridContext._config.multiSelection) {
                        tableCheckboxHeader = "<th>Select</th>";
                    }

                    result += `<div style="width: 90%;padding-left: 20px">
                                <table class="table table-hover table-no-bordered">
                                    <thead>
                                        <tr class="table-header">
                                            ${tableCheckboxHeader}
                                            <th>ID</th>
                                            <th>Sex</th>
                                            <th>Father</th>
                                            <th>Mother</th>
                                            <th>Affectation Status</th>
                                            <th>Life Status</th>
                                            <th>Year of Birth</th>
                                            <th>Creation Date</th>
                                            <th>Status</th>
                                        </tr>
                                    </thead>
                                    <tbody>`;

                    for (let member of row.members) {
                        let tableCheckboxRow = "";
                        // If parent row is checked and there is only one samlpe then it must be selected
                        if (this.gridContext._config.multiSelection) {
                            let checkedStr = "";
                            for (let family of this.gridContext.families) {
                                if (family.id === row.id && row.members.length === 1) {
                                    // TODO check member has been checked before, we need to store them
                                    checkedStr = "checked";
                                    break;
                                }
                            }

                            tableCheckboxRow = `<td><input id='${this.gridContext.prefix}${member.id}Checkbox' type='checkbox' ${checkedStr}></td>`;
                        }

                        let father = (UtilsNew.isNotEmpty(member.father.id)) ? member.father.id : "-";
                        let mother = (UtilsNew.isNotEmpty(member.mother.id)) ? member.mother.id : "-";
                        let affectation = (UtilsNew.isNotEmpty(member.affectationStatus)) ? member.affectationStatus : "-";
                        let lifeStatus = (UtilsNew.isNotEmpty(member.lifeStatus)) ? member.lifeStatus : "-";
                        let dateOfBirth = UtilsNew.isNotEmpty(member.dateOfBirth) ? moment(member.dateOfBirth, "YYYYMMDD").format('YYYY') : "-";
                        let creationDate = moment(member.creationDate, "YYYYMMDDHHmmss").format('D MMM YYYY');

                        result += `<tr class="detail-view-row">
                                        ${tableCheckboxRow}
                                        <td>${member.id}</td>
                                        <td>${member.sex}</td>
                                        <td>${father}</td>
                                        <td>${mother}</td>
                                        <td>${affectation}</td>
                                        <td>${lifeStatus}</td>
                                        <td>${dateOfBirth}</td>
                                        <td>${creationDate}</td>
                                        <td>${member.status.name}</td>
                                   </tr>`;
                    }
                    result += `</tbody></table></diV>`;
                } else {
                    result += "No members found";
                }

                result += "</div></div>";
                return result;
            }

            membersFormatter(value, row) {
                if (UtilsNew.isNotEmptyArray(row.members)) {
                    let members = "";
                    for (let member of row.members) {
                        members += `<li style='padding: 0px 15px'>
                                            <span>
                                                ${member.id} (${member.sex})
                                            </span>
                                       </li>`;
                    }

                    let html = `<div class="dropdown members-link-dropdown" style="white-space: nowrap">
                                <a id="${this.prefix}dropdownMenu1" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"
                                    style="cursor: pointer">
                                    ${row.members.length} members found
                                </a>
                                <ul class="dropdown-menu" aria-labelledby="${this.prefix}dropdownMenu1" style="font-size: 1.25rem;margin-top: 0px;padding: 10px 0px">
                                    <!--<li class="dropdown-header">HPO</li>-->
                                    ${members}
                                </ul>
                            </div>`;

                    return html;
                } else {
                    return 'No members found';
                }
            }

            disordersFormatter(value, row) {
                if (UtilsNew.isNotEmptyArray(row.phenotypes)) {
                    let disorderSources = this._config.disorderSources;
                    let phenotypes = "<div>";
                    for (let phenotype of row.phenotypes) {
                        if (disorderSources != null && disorderSources.includes(phenotype.source)) {
                            phenotypes += `<span>${phenotype.id}</span>`;
                        }
                    }
                    phenotypes += "</div>";
                    return phenotypes;
                } else {
                    return '-';
                }
            }

            phenotypesFormatter(value, row) {
                if (UtilsNew.isNotEmptyArray(row.phenotypes)) {
                    let disorderSources = this._config.disorderSources;
                    let counter = 0;
                    let phenotypes = "";
                    for (let phenotype of row.phenotypes) {
                        if (disorderSources != null && !disorderSources.includes(phenotype.source)) {
                            phenotypes += "<li style='padding: 0px 15px'>";
                            if (UtilsNew.isNotUndefinedOrNull(phenotype.source) && phenotype.source.toUpperCase() === "HPO") {
                                phenotypes += `<span>
                                                    <a target='_blank' href="https://hpo.jax.org/app/browse/term/${phenotype.id}">${phenotype.id} </a>(${phenotype.status})
                                               </span>
                                               `;
                                counter++;
                            } else {
                                phenotypes += `${phenotype.id} (${phenotype.status})`;
                            }
                            phenotypes += "</li>";
                        }
                    }

                    let html = `<div class="dropdown phenotypes-link-dropdown" style="white-space: nowrap">
                                <a id="${this.prefix}dropdownMenu1" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"
                                    style="cursor: pointer">
                                    ${counter} terms found
                                </a>
                                <ul class="dropdown-menu" aria-labelledby="${this.prefix}dropdownMenu1" style="font-size: 1.25rem;margin-top: 0px;padding: 10px 0px">
                                    <!--<li class="dropdown-header">HPO</li>-->
                                    ${phenotypes}
                                </ul>
                            </div>`;

                    return html;
                } else {
                    return '-';
                }
            }

            customAnnotationFormatter(value, row) {
                // debugger
            }

            dateFormatter(value, row) {
                if (UtilsNew.isUndefinedOrNull(value)) {
                    return "-";
                }
                return moment(value, "YYYYMMDDHHmmss").format('D MMM YYYY');
            }

            _initTableColumns() {
                // Check column visibility
                let customAnnotationVisible = (UtilsNew.isNotUndefinedOrNull(this._config.customAnnotations)
                    && UtilsNew.isNotEmptyArray(this._config.customAnnotations.fields));

                let columns = [];
                if (this._config.multiSelection) {
                    columns.push({
                        field: 'state',
                        checkbox: true,
                        // formatter: this.stateFormatter,
                        class: "cursor-pointer",
                        eligible: false
                    });
                }

                this._columns = [
                    columns.concat(
                        [
                            {
                                title: 'Family',
                                field: 'id',
                                sortable: true,
                                halign: this._config.header.horizontalAlign
                            },
                            {
                                title: 'Members',
                                field: 'members',
                                formatter: this.membersFormatter.bind(this),
                                halign: this._config.header.horizontalAlign,
                            },
                            {
                                title: 'Disorders',
                                field: 'disorders',
                                formatter: this.disordersFormatter.bind(this),
                                halign: this._config.header.horizontalAlign
                            },
                            {
                                title: 'Phenotypes',
                                field: 'phenotypes',
                                formatter: this.phenotypesFormatter.bind(this),
                                halign: this._config.header.horizontalAlign
                            },
                            {
                                title: 'Custom Annotations',
                                field: 'customAnnotation',
                                formatter: this.customAnnotationFormatter,
                                visible: customAnnotationVisible,
                                halign: this._config.header.horizontalAlign
                            },
                            {
                                title: 'Creation Date',
                                field: 'creationDate',
                                formatter: this.dateFormatter,
                                sortable: true,
                                halign: this._config.header.horizontalAlign
                            },
                            {
                                title: 'Status',
                                field: 'status.name',
                                halign: this._config.header.horizontalAlign
                            },
                        ])
                ];

                return this._columns;
            }

            getDefaultConfig() {
                return {
                    pagination: true,
                    pageSize: 10,
                    pageList: [10, 25, 50],
                    showExport: false,
                    detailView: true,
                    detailFormatter: this.detailFormatter, // function with the detail formatter
                    multiSelection: false,
                    header: {
                        horizontalAlign: 'center',
                        verticalAlign: 'bottom'
                    },
                    disorderSources: ["ICD", "ICD10", "GelDisorder"],
                    customAnnotations: {
                        title: "Custom Annotation",
                        fields: []
                    }
                }
            }
        }

        customElements.define(OpencgaFamilyGrid.is, OpencgaFamilyGrid);
    </script>
</dom-module>
