<dom-module id="opencga-panel-transcript-view">
    <template>

        <div class="row" style="margin: 15px">

            <div style="margin: 2px 2px">
                <label class="col-md-2">Gene:</label>
                <select class="selectpicker col-md-10" id="{{prefix}}-geneSelect">
                    <template is="dom-repeat" items="{{_genes}}">
                        <option data-gene="{{item}}">{{item.name}}</option>
                    </template>
                </select>
            </div>

            <div style="margin: 4px 2px">
                <label class="col-md-2">Low coverage threshold:</label>
                <select class="selectpicker col-md-10" id="{{prefix}}-lowCoverageThreshold" on-change="onLowCoverageThresholdChange">
                    <option>5</option>
                    <option>10</option>
                    <option>15</option>
                    <option selected>20</option>
                    <option>25</option>
                    <option>30</option>
                    <option>35</option>
                    <option>40</option>
                </select>
            </div>

            <!--<div id="{{prefix}}-svg" style="width: 100%; height: 500px; margin-top: 10px;"></div>-->
            <div id="{{prefix}}-othersvg" style="width: 100%; margin-top: 10px;"></div>

        </div>
    </template>

    <script>
        class OpencgaPanelTranscriptView extends Polymer.Element {

            static get is() {
                return 'opencga-panel-transcript-view';
            }

            static get properties() {
                return {
                    opencgaSession: {
                        type: Object
                    },
                    cellbaseClient: {
                        type: Object
                    },
                    clinicalAnalysis: {
                        type: Object,
                    },
                    panelId: {
                        type: String,
                        // observer: "panelIdObserver"
                    },
                    // panel: {
                    //     type: Object
                    // },
                    geneIds: {
                        type: Array
                    },
                    config: {
                        type: Object
                    }
                }
            }

            static get observers() {
                return ['propertyObserver(opencgaSession, clinicalAnalysis, panelId, geneIds, config)'];
            }

            _attachDom(dom) {
                this.appendChild(dom);
            }

            constructor() {
                super();

                this._init();
            }

            _init() {
                this.prefix = "PanelTranscriptView" + Utils.randomString(6);

                // Initially we set the default config, this will be overridden if 'config' is passed
                this._config = this.getDefaultConfig();
            }


            connectedCallback() {
                super.connectedCallback();

                // We add this first listener to get a call whenever the first element is loaded
                $(`#${this.prefix}-geneSelect`).on('loaded.bs.select', this.onGeneChange.bind(this));

                // We add this listener to receive any future change over the selected genes
                $(`#${this.prefix}-geneSelect`).on('changed.bs.select', this.onGeneChange.bind(this));
            }

            propertyObserver(opencgaSession, clinicalAnalysis, panelId, genes, config) {
                if (UtilsNew.isNotUndefinedOrNull(config)) {
                    this._config = Object.assign(this.getDefaultConfig(), config);
                }

                let _genes = [];
                let _this = this;
                if (UtilsNew.isNotUndefinedOrNull(opencgaSession) && UtilsNew.isNotEmpty(panelId)) {
                    this.opencgaSession.opencgaClient.panels().info(panelId, {study: this.opencgaSession.study.fqn})
                        .then(function(response) {
                            _this._genes = response.response[0].result[0].genes;
                        });
                }
                // this._genes = _genes;
            }

            onLowCoverageThresholdChange(e) {
                this._displaySVG($(`#${this.prefix}-geneSelect`).selectpicker('val'), e.currentTarget.value);
            }

            onGeneChange(e, clickedIndex, isSelected, previousValue) {
                this._displaySVG(e.currentTarget.value, $(`#${this.prefix}-lowCoverageThreshold`).selectpicker('val'));
            }

            _displaySVG(geneId, threshold) {
                // TODO: Remove hardcoded file
                let fatherFile = "NA12877_S1.bam"; // father
                let motherFile = "NA12878_S1.bam"; // mother
                let daughterFile = "NA12879_S1.bam"; // daughter

                if (UtilsNew.isUndefinedOrNull(this.fatherTrack)) {
                    this.fatherTrack = new LinearCoverageTrack({
                        name: "Father",
                        opencga: {
                            client: this.opencgaSession.opencgaClient
                        },
                        targetId: `${this.prefix}-othersvg`,
                        config: {
                            width: $(`#${this.prefix}-othersvg`).width()
                        }
                    });
                }

                if (UtilsNew.isUndefinedOrNull(this.motherTrack)) {
                    this.motherTrack = new LinearCoverageTrack({
                        name: "Mother",
                        opencga: {
                            client: this.opencgaSession.opencgaClient
                        },
                        targetId: `${this.prefix}-othersvg`,
                        config: {
                            width: $(`#${this.prefix}-othersvg`).width()
                        }
                    });
                }

                if (UtilsNew.isUndefinedOrNull(this.daughterTrack)) {
                    this.daughterTrack = new LinearCoverageTrack({
                        name: "Daughter",
                        opencga: {
                            client: this.opencgaSession.opencgaClient
                        },
                        targetId: `${this.prefix}-othersvg`,
                        config: {
                            width: $(`#${this.prefix}-othersvg`).width()
                        }
                    });
                }

                if (UtilsNew.isUndefinedOrNull(this.geneTrack)) {
                    this.geneTrack = new LinearGeneTrack({
                        name: geneId,
                        targetId: `${this.prefix}-othersvg`,
                        width: $(`#${this.prefix}-othersvg`).width()
                    })
                }

                let _this = this;
                this.cellbaseClient.get('feature', 'gene', geneId, 'info',
                    { assembly: this.opencgaSession.project.organism.assembly }, {})
                    .then(function (response) {
                        let gene = response.response[0].result[0];

                        let region = new Region(`${gene.chromosome}:${gene.start}-${gene.end}`);

                        _this.fatherTrack.draw({
                            query: {
                                region: region,
                                study: _this.opencgaSession.study.fqn,
                                fileId: fatherFile
                            }, config: {
                                regionOffset: _this._config.offset,
                                lowCoverageThreshold: threshold
                            }
                        });

                        _this.motherTrack.draw({
                            query: {
                                region: region,
                                study: _this.opencgaSession.study.fqn,
                                fileId: motherFile
                            }, config: {
                                regionOffset: _this._config.offset,
                                lowCoverageThreshold: threshold
                            }
                        });

                        _this.daughterTrack.draw({
                            query: {
                                region: region,
                                study: _this.opencgaSession.study.fqn,
                                fileId: daughterFile
                            }, config: {
                                regionOffset: _this._config.offset,
                                lowCoverageThreshold: threshold
                            }
                        });

                        _this.geneTrack.draw(gene);

                        // let metaTranscript = _this._createMetaTranscript(gene);
                        //
                        // let svgDiv = document.getElementById(`${_this.prefix}-svg`);
                        // let windowSize = Math.round(((gene.end - gene.start) * 1.85 ) / svgDiv.offsetWidth);
                        //
                        // let promises = [];
                        // promises.push(_this.opencgaSession.opencgaClient.alignments().coverage(fatherFile,
                        //     { study: _this.opencgaSession.study.fqn, gene: geneId, geneOffset: 300,
                        //         windowSize: windowSize }));
                        //
                        // promises.push(_this.opencgaSession.opencgaClient.alignments().lowCoverage(fatherFile,
                        //     { study: _this.opencgaSession.study.fqn, gene: geneId, geneOffset: 300,
                        //         minCoverage: threshold }));
                        //
                        // promises.push(_this.opencgaSession.opencgaClient.alignments().coverage(motherFile,
                        //     { study: _this.opencgaSession.study.fqn, gene: geneId, geneOffset: 300,
                        //         windowSize: windowSize }));
                        //
                        // promises.push(_this.opencgaSession.opencgaClient.alignments().lowCoverage(motherFile,
                        //     { study: _this.opencgaSession.study.fqn, gene: geneId, geneOffset: 300,
                        //         minCoverage: threshold }));
                        //
                        // promises.push(_this.opencgaSession.opencgaClient.alignments().coverage(daughterFile,
                        //     { study: _this.opencgaSession.study.fqn, gene: geneId, geneOffset: 300,
                        //         windowSize: windowSize }));
                        //
                        // promises.push(_this.opencgaSession.opencgaClient.alignments().lowCoverage(daughterFile,
                        //     { study: _this.opencgaSession.study.fqn, gene: geneId, geneOffset: 300,
                        //         minCoverage: threshold }));
                        //
                        // Promise.all(promises).then(function(responses) {
                        //     let tracks = [];
                        //
                        //     tracks.push({
                        //         name: "Father",
                        //         type: "coverage",
                        //         data: {
                        //             coverage: responses[0].response[0].result[0],
                        //             lowCoverage: responses[1].response[0].result
                        //         },
                        //         order: 1
                        //     });
                        //
                        //     tracks.push({
                        //         name: "Mother",
                        //         type: "coverage",
                        //         data: {
                        //             coverage: responses[2].response[0].result[0],
                        //             lowCoverage: responses[3].response[0].result
                        //         },
                        //         order: 2
                        //     });
                        //
                        //     tracks.push({
                        //         name: "Daughter",
                        //         type: "coverage",
                        //         data: {
                        //             coverage: responses[4].response[0].result[0],
                        //             lowCoverage: responses[5].response[0].result
                        //         },
                        //         order: 0
                        //     });
                        //
                        //     if (UtilsNew.isNotEmptyArray(gene.transcripts[0].tfbs)) {
                        //         tracks.push({
                        //             name: "TFBS",
                        //             type: "feature",
                        //             data: gene.transcripts[0].tfbs
                        //         });
                        //     }
                        //
                        //     let exonViewer = new ExonViewer(`${_this.prefix}-svg`, metaTranscript, tracks);
                        //
                        //     // Modify the width to use the whole width of the div
                        //     let config = exonViewer.getDefaultConfig();
                        //     config.width = svgDiv.offsetWidth;
                        //     // config.display.compact = true;
                        //
                        //     exonViewer.render(config);
                        // });

                    });
            }

            _createMetaTranscript(gene) {
                let exons = [];

                // We create a copy of all the exons from the first transcript
                for (let i = 0; i < gene.transcripts[0].exons.length; i++) {
                    exons.push(Object.assign({}, gene.transcripts[0].exons[i]));
                }
                if (gene.transcripts.length === 1) {
                    return exons;
                }

                // We need to modify the information we have to include the exons of each of the transcripts
                for (let i = 1; i < gene.transcripts.length; i++) {
                    // lastIndex visited from the final list of exons to avoid looping again the first positions
                    // if it is not necessary
                    let lastIndex = 0;
                    for (let j = 0; j < gene.transcripts[i].exons.length; j++) {
                        let exon = gene.transcripts[i].exons[j];

                        for (let w = lastIndex; w < exons.length; w++) {
                            // We check if the current exon is located before the first of the exons we have stored
                            if (exons[w].start > exon.end) {
                                exons.splice(lastIndex + w, 0, Object.assign({}, exon));
                                lastIndex += w + 1;
                                break;
                            }

                            let changed = false;
                            // Exon stored                   |---------|
                            // Exon analysed             |-------
                            if (exons.start < exons[w].start && exon.end >= exons[w].start) {
                                // We modify the start value of the stored exon
                                exons[w].start = exon.start;
                                changed = true;
                            }

                            // Exon stored                   |---------|
                            // Exon analysed                       -------|
                            if (exons.start >= exons[w].start && exon.end > exons[w].end) {
                                // We modify the end value of the stored exon
                                exons[w].end = exon.end;
                                changed = true;
                            }

                            if (changed) {
                                lastIndex = w;
                                break;
                            }
                        }
                    }
                }

                // Once we have merged all the exons, we need to remove any overlapping exon that might have resulted
                // from the previous merge
                let finalListOfExons = [];
                do {
                    for (let i = 0; i < exons.length - 1; i++) {
                        let exon = exons[i];
                        finalListOfExons.push(exon);

                        if (i === exons.length - 2) {
                            if (exons[i + 1].start <= exon.end) {
                                exon.end = Math.max(exon.end, exons[i + 1].end);
                                // We increment i to skip the next exon
                                i++;
                            } else {
                                finalListOfExons.push(exons[i + 1]);
                            }
                        } else {
                            if (exons[i + 1].start <= exon.end) {
                                exon.end = Math.max(exon.end, exons[i + 1].end);
                                // We increment i to skip the next exon
                                i++;
                            }
                        }
                    }

                    if (finalListOfExons.length !== exons.length) {
                        // We copy finalListOfExons into exons (source) and empty finalListOfExons to do another iteration
                        exons = finalListOfExons;
                        finalListOfExons = [];
                    }
                } while (finalListOfExons.length !== exons.length);

                return finalListOfExons;
            }

            getDefaultConfig() {
                return {
                    offset: 2500
                }
            }
        }

        customElements.define(OpencgaPanelTranscriptView.is, OpencgaPanelTranscriptView);
    </script>
</dom-module>
