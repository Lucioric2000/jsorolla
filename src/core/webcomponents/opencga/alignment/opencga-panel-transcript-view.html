<!--
  ~ Copyright 2015-2019 OpenCB
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~     http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<link rel="import" href="../../cellbase/core/cellbase-gene-filter.html">

<dom-module id="opencga-panel-transcript-view">
    <template>
        <style include="jso-styles">
            .form-section-title {
                padding: 5px 0px;
                width: 80%;
                border-bottom-width: 1px;
                border-bottom-style: solid;
                border-bottom-color: #ddd
            }

            .jso-label-title {
                width: 15em !important;
            }
        </style>

        <div class="row" style="padding: 0px 10px; margin: 10px 0px;">

            <template is="dom-if" if="{{_disabled}}">
                <h4 style="color: #940303; margin: 20px 0px; text-align: center">
                    No files available.
                </h4>
            </template>

            <template is="dom-if" if="{{!_disabled}}">
                <div class="col-md-12">
                    <!--<h3 class="form-section-title">Low Coverage Filters</h3>-->

                    <div style="display: block; cursor:pointer;" on-click="toggleCollapsedFilter"
                         data-toggle="collapse" href$="#{{prefix}}collapsibleFilter">
                        <h3 class="form-section-title">
                            <template is="dom-if" if="{{_filtersCollapsed}}">
                                <i class="fa fa-caret-right" aria-hidden="true" style="padding-right: 5px"></i>
                            </template>
                            <template is="dom-if" if="{{!_filtersCollapsed}}">
                                <i class="fa fa-caret-down" aria-hidden="true" style="padding-right: 5px"></i>
                            </template>
                            Low Coverage Filters
                        </h3>
                    </div>


                    <div id="{{prefix}}collapsibleFilter" class="form-horizontal collapse in" style="padding: 5px 10px">

                        <div class="form-group">
                            <label class="control-label col-md-1 jso-label-title">Search by Gene</label>
                            <div class="col-md-3">
                                <cellbase-gene-filter cellbase-client="{{cellbaseClient}}"
                                                      erase="{{eraseSearchGene}}"
                                                      on-genechange="onInputGeneChange">
                                </cellbase-gene-filter>
                                <!--<button type="button" class="btn btn-primary" on-click="onSearchGeneClicked">Search</button>-->
                                <!--<span class="input-group-btn">-->
                                <!--<button class="btn btn-default" type="button" on-click="onSearchGeneClicked">-->
                                <!--<i class="fa fa-eraser" aria-hidden="true"></i>-->
                                <!--</button>-->
                                <!--</span>-->
                            </div>
                        </div>

                        <div class="form-group">
                            <label class="control-label col-md-1 jso-label-title">Select a Gene from Panel</label>
                            <div class="col-md-3">
                                <select class="selectpicker" id="{{prefix}}-geneSelect" data-live-search="true" data-max-options="1"
                                        on-dom-change="renderDomRepeat" multiple>
                                    <optgroup label="Selected Genes">
                                        <template is="dom-repeat" items="{{geneIds}}" as="geneId">
                                            <option>{{geneId}}</option>
                                        </template>
                                    </optgroup>

                                    <template is="dom-repeat" items="{{_genePanels}}" as="panel">
                                        <optgroup label="{{panel.name}}">
                                            <template is="dom-repeat" items="{{panel.genes}}" as="gene">
                                                <option>{{gene.name}}</option>
                                            </template>
                                        </optgroup>
                                    </template>
                                </select>
                            </div>
                        </div>

                        <!--on-change="onLowCoverageThresholdChange"-->
                        <div class="form-group">
                            <label class="control-label col-md-1 jso-label-title">Select Low Coverage</label>
                            <div class="col-md-3">
                                <select class="selectpicker" id="{{prefix}}-lowCoverageThreshold" data-width="fit">
                                    <option>5</option>
                                    <option>10</option>
                                    <option>15</option>
                                    <option selected>20</option>
                                    <option>25</option>
                                    <option>30</option>
                                    <option>35</option>
                                    <option>40</option>
                                </select>
                            </div>
                        </div>

                        <div class="form-group">
                            <div class="col-md-offset-3 col-md-9">
                                <button type="submit" class="btn btn-primary" on-click="onClear">Clear</button>
                                <button type="submit" class="btn btn-primary" on-click="onRender">Render</button>
                            </div>
                        </div>
                    </div>

                </div>

                <div class="col-md-12">
                    <h3 class="form-section-title">{{selectedGene}} Gene Low Coverage</h3>
                    <div id="{{prefix}}-svg" style="padding: 20px"></div>
                </div>

                <!--Low covered regions table-->
                <div class="col-md-12">
                    <div style='padding: 10px 0px 10px 25px'>
                        <h4>Low covered regions</h4>
                    </div>

                    <div style='padding: 5px 50px'>
                        <table id="{{prefix}}LowCoveredRegions" class="table table-hover table-no-bordered">
                            <thead>
                            <tr>
                                <th rowspan="2">Position</th>
                                <th rowspan="2">Length</th>
                                <th rowspan="1" colspan="3" style$="{{_probandFile.style}}">
                                    {{_probandFile.name}}
                                    <i class$="fa {{_probandFile.icon}} fa-lg" style='padding-left: 5px'></i>
                                </th>
                                <template is="dom-repeat" items="{{_otherFiles}}" as="file">
                                    <th rowspan="1" colspan="4" style$="{{file.style}}">
                                        {{file.name}}
                                        <i class$="fa {{file.icon}} fa-lg" style='padding-left: 5px'></i>
                                    </th>
                                </template>
                                <!--                                <th rowspan="1" colspan$="{{_numberOfFiles}}" style="text-align: center">Medium coverage</th>-->

                            </tr>
                            <tr>
                                <th rowspan="1">Average</th>
                                <th rowspan="1">Max</th>
                                <th rowspan="1">Min</th>

                                <template is="dom-repeat" items="{{_otherFiles}}" as="file">
                                    <th rowspan="1">% covered</th>
                                    <th rowspan="1">Average</th>
                                    <th rowspan="1">Max</th>
                                    <th rowspan="1">Min</th>
                                </template>
                            </tr>
                            </thead>
                            <tbody>
                            <template is="dom-repeat" items="{{_lowCoverageValues}}" as="coverage">
                                <tr class="detail-view-row">
                                    <td>{{coverage.region}}</td>
                                    <td>{{coverage.length}}</td>
                                    <td>{{coverage.stats.average}}</td>
                                    <td>{{coverage.stats.max}}</td>
                                    <td>{{coverage.stats.min}}</td>
                                    <template is="dom-repeat" items="{{_otherFiles}}" as="file">
                                        <td>{{_getCoverage(coverage, file)}}</td>
                                        <td>{{_getAverage(coverage, file)}}</td>
                                        <td>{{_getMax(coverage, file)}}</td>
                                        <td>{{_getMin(coverage, file)}}</td>
                                    </template>
                                </tr>
                            </template>
                            </tbody>
                        </table>
                    </div>
                </div>
            </template>
        </div>
    </template>

    <script>
        class OpencgaPanelTranscriptView extends Polymer.Element {

            static get is() {
                return 'opencga-panel-transcript-view';
            }

            static get properties() {
                return {
                    opencgaSession: {
                        type: Object
                    },
                    cellbaseClient: {
                        type: Object
                    },
                    clinicalAnalysisId: {
                        type: String,
                        observer: "clinicalAnalysisIdObserver"
                    },
                    clinicalAnalysis: {
                        type: Object
                    },
                    geneIds: {
                        type: Array
                    },
                    panelIds: {
                        type: Array
                    },
                    config: {
                        type: Object
                    }
                }
            }

            _attachDom(dom) {
                this.appendChild(dom);
            }

            static get observers() {
                return ['propertyObserver(opencgaSession, clinicalAnalysis, panelIds, geneIds, config)'];
            }

            constructor() {
                super();

                this._init();
            }

            _init() {
                this.prefix = "PanelTranscriptView" + Utils.randomString(6);

                this.eraseSearchGene = false;
                this._filtersCollapsed = false;

                // The component will show an error message instead of the whole app if no alignment files are found
                this._disabled = true;

                this._lowCoverageValues = [];

                // Initially we set the default config, this will be overridden if 'config' is passed
                this._config = this.getDefaultConfig();
            }


            connectedCallback() {
                super.connectedCallback();

                // We add this listener to receive any future change over the selected genes
                $(`#${this.prefix}-geneSelect`).on('changed.bs.select', this.onGeneChange.bind(this));

                $('select.selectpicker').selectpicker('render');
                $('select.selectpicker').selectpicker({
                    iconBase: 'fa',
                    tickIcon: 'fa-check'
                });
            }

            propertyObserver(opencgaSession, clinicalAnalysis, panelIds, geneIds, config) {
                this._config = Object.assign(this.getDefaultConfig(), config);
                // if (UtilsNew.isNotUndefinedOrNull(config)) {
                // }

                this._files = [];
                this._numberOfFiles = 0;

                this._autoRenderWhenFilesAreRetrieved = false;
                this._initialiseCoverageTracks = true;

                if (UtilsNew.isNotUndefinedOrNull(this.opencgaSession)) {

                    let _this = this;
                    if (UtilsNew.isNotEmptyArray(this.panelIds)) {
                        this.opencgaSession.opencgaClient.panels().info(panelIds.join(","),
                            {
                                study: _this.opencgaSession.study.fqn,
                                include: "id,name,genes"
                            })
                            .then(function(response) {
                                // _this._panelGenesAvailable = true;
                                let _panels = [];
                                for (let panel of response.response) {
                                    _panels.push(panel.result[0]);
                                }
                                _this._genePanels = _panels;
                            })
                            .catch((response) => {
                                console.error("An error occurred fetching clinicalAnalysis: ", response)
                            });
                    } else {
                        this._genePanels = [];
                    }

                    if (UtilsNew.isNotUndefinedOrNull(clinicalAnalysis)) {
                        // let result = response.response[0].result[0];

                        let disorder = clinicalAnalysis.disorder.id;

                        let files = [];

                        let members = {}; // member_id : member
                        let samples = {}; // sample_id : member
                        for (let i = 0; i < clinicalAnalysis.family.members.length; i++) {
                            let member = clinicalAnalysis.family.members[i];
                            members[member.id] = member;
                            if (UtilsNew.isNotEmptyArray(member.samples)) {
                                for (let j = 0; j < member.samples.length; j++) {
                                    samples[member.samples[j].id] = member;
                                }
                            }
                        }

                        let availableBigWigs = {}; // sample id - file id
                        for (let key in clinicalAnalysis.files) {
                            for (let i = 0; i < clinicalAnalysis.files[key].length; i++) {
                                if (clinicalAnalysis.files[key][i].format === "BIGWIG") {
                                    availableBigWigs[key] = clinicalAnalysis.files[key][i].id;
                                }
                            }
                        }

                        // Get proband sample
                        for (let i = 0; i < clinicalAnalysis.proband.samples.length; i++) {
                            if (availableBigWigs.hasOwnProperty(clinicalAnalysis.proband.samples[i].id)) {
                                // In theory, there should only be one BAM file available for each member
                                files.push({
                                    id: availableBigWigs[clinicalAnalysis.proband.samples[i].id],
                                    name: "Proband '" + clinicalAnalysis.proband.id + "'",
                                    sex: clinicalAnalysis.proband.sex,
                                    isProband: true,
                                    affectationStatus: this._getAffectationStatus(clinicalAnalysis.proband, disorder)
                                });

                                // Take the bam out of the map
                                delete availableBigWigs[clinicalAnalysis.proband.samples[i].id];
                            }
                        }

                        // Get mother
                        if (UtilsNew.isNotUndefinedOrNull(clinicalAnalysis.proband.mother)
                            && UtilsNew.isNotEmpty(clinicalAnalysis.proband.mother.id)) {
                            let motherId = clinicalAnalysis.proband.mother.id;
                            if (members.hasOwnProperty(motherId) && UtilsNew.isNotEmptyArray(members[motherId].samples)
                                && availableBigWigs.hasOwnProperty(members[motherId].samples[0].id)) {
                                files.push({
                                    id: availableBigWigs[members[motherId].samples[0].id],
                                    name: "Mother '" + motherId + "'",
                                    sex: members[motherId].sex,
                                    isProband: false,
                                    affectationStatus: this._getAffectationStatus(members[motherId], disorder)
                                });

                                // Take the bam out of the map
                                delete availableBigWigs[members[motherId].samples[0].id];
                            }
                        }

                        // Get father
                        if (UtilsNew.isNotUndefinedOrNull(clinicalAnalysis.proband.father)
                            && UtilsNew.isNotEmpty(clinicalAnalysis.proband.father.id)) {
                            let fatherId = clinicalAnalysis.proband.father.id;
                            if (members.hasOwnProperty(fatherId) && UtilsNew.isNotEmptyArray(members[fatherId].samples)
                                && availableBigWigs.hasOwnProperty(members[fatherId].samples[0].id)) {
                                files.push({
                                    id: availableBigWigs[members[fatherId].samples[0].id],
                                    name: "Father '" + fatherId + "'",
                                    sex: members[fatherId].sex,
                                    isProband: false,
                                    affectationStatus: this._getAffectationStatus(members[fatherId], disorder)
                                });

                                // Take the bam out of the map
                                delete availableBigWigs[members[fatherId].samples[0].id];
                            }
                        }

                        // If there are any remaining BAM files, we will add them in a random position
                        for (let key in availableBigWigs) {
                            if (samples.hasOwnProperty(key)) {
                                files.push({
                                    id: availableBigWigs[key],
                                    name: "Member '" + samples[key].id + "'",
                                    sex: samples[key].sex,
                                    isProband: false,
                                    affectationStatus: this._getAffectationStatus(samples[key], disorder)
                                });
                            } else {
                                files.push({
                                    id: availableBigWigs[key],
                                    name: "Sample '" + key + "'",
                                    isProband: false
                                });
                            }
                        }

                        this._disabled = UtilsNew.isEmptyArray(files);

                        this._files = files;
                        this._numberOfFiles = files.length;

                        if (this._autoRenderWhenFilesAreRetrieved) {
                            this._displaySVG($(`#${_this.prefix}-geneSelect`).selectpicker('val'),
                                $(`#${this.prefix}-lowCoverageThreshold`).selectpicker('val'));

                            this._autoRenderWhenFilesAreRetrieved = false;
                        }
                    } else {
                        this._disabled = true;
                    }
                }
            }

            /**
             * Fetch the CinicalAnalysis object from REST and trigger the observer call.
             */
            clinicalAnalysisIdObserver() {
                if (UtilsNew.isNotUndefinedOrNull(this.opencgaSession) && UtilsNew.isNotEmpty(this.clinicalAnalysisId)) {
                    let _this = this;
                    this.opencgaSession.opencgaClient.clinical().info(this.clinicalAnalysisId, {study: this.opencgaSession.study.fqn})
                        .then(function(response) {
                            // This will trigger the call clinicalAnalysis observer
                            _this.clinicalAnalysis = response.response[0].result[0];
                        })
                        .catch((response) => {
                            console.error("An error occurred fetching clinicalAnalysis: ", response)
                        });
                }
            }

            _getAffectationStatus(member, disorderId) {
                let status = "UNAFFECTED";
                if (UtilsNew.isNotEmptyArray(member.disorders)) {
                    for (let disorder of member.disorders) {
                        if (UtilsNew.isNotUndefinedOrNull(disorder) && disorder.id === disorderId) {
                            status = "AFFECTED";
                            break;
                        }
                    }
                }
                return status;
            }

            renderDomRepeat(e) {
                $(`#${this.prefix}-geneSelect`).selectpicker('refresh');
                $(`#${this.prefix}-geneSelect`).selectpicker('deselectAll');
            }

            toggleCollapsedFilter() {
                // this.set("_filtersCollapsed", !this._filtersCollapsed);

                this._filtersCollapsed = !this._filtersCollapsed;
            }

            onInputGeneChange(e) {
                this._inputGene = e.detail.gene;

                $("#" + this.prefix + "-geneSelect").selectpicker('val', []);
            }

            onGeneChange(e) {
                this.selectedGene = $(`#${this.prefix}-geneSelect`).selectpicker('val');

                // This erase the text input of cellbase-gene web component
                this.eraseSearchGene = !this.eraseSearchGene;
                // this._displaySVG(e.currentTarget.value, $(`#${this.prefix}-lowCoverageThreshold`).selectpicker('val'));
            }

            onRender(e) {
                if (UtilsNew.isNotEmpty(this._inputGene)) {
                    this.selectedGene = this._inputGene;
                    this._displaySVG(this.selectedGene, $(`#${this.prefix}-lowCoverageThreshold`).selectpicker('val'));
                } else if (UtilsNew.isNotEmpty(this.selectedGene)) {
                    this._displaySVG(this.selectedGene, $(`#${this.prefix}-lowCoverageThreshold`).selectpicker('val'));
                }
            }

            _displaySVG(geneId, threshold) {
                if (UtilsNew.isEmptyArray(this._files)) {
                    // Probably the files are being fetched at this same moment. Force them to be rendered automatically after that
                    this._autoRenderWhenFilesAreRetrieved = true;
                    return;
                }

                if (UtilsNew.isEmpty(geneId)) {
                    return;
                }

                this.lastGeneId = geneId;

                if (this._initialiseCoverageTracks) {
                    let tracks = [];

                    this._otherFiles = [];
                    this._probandFile = {};

                    for (let i = 0; i < this._files.length; i++) {

                        let style = "";
                        if (UtilsNew.isNotEmpty(this._files[i].affectationStatus)) {
                            if (this._files[i].affectationStatus === "AFFECTED") {
                                style = "color: darkred";
                            } else if (this._files[i].affectationStatus === "UNKNOWN") {
                                style = "color: gray";
                            }
                        }
                        if (this._files[i].isProband) {
                            style += ";font-weight: bold";
                        }

                        let sampleIcon = this._config.sexIConMap[this._files[i].sex];

                        let htmlTitle = `<span style="${style}">
                                ${this._files[i].name}
                                <i class='fa ${sampleIcon} fa-lg' style='padding-left: 5px'></i>
                            </span>`;

                        if (this._files[i].isProband) {
                            this._probandFile = {
                                style: style,
                                name: this._files[i].name,
                                icon: sampleIcon,
                                id: this._files[i].id
                            }
                        } else {
                            this._otherFiles.push({
                                style: style,
                                name: this._files[i].name,
                                icon: sampleIcon,
                                id: this._files[i].id
                            });
                        }

                        tracks.push(new LinearCoverageTrack({
                                htmlTitle: htmlTitle,
                                opencga: {
                                    client: this.opencgaSession.opencgaClient
                                },
                                targetId: `${this.prefix}-svg`
                            }, {
                                width: $(`#${this.prefix}-svg`).width()
                            })
                        );

                        this.coverageTracks = tracks;
                    }
                    this._initialiseCoverageTracks = false;
                }

                if (UtilsNew.isUndefinedOrNull(this.geneTrack)) {
                    this.geneTrack = new LinearGeneTrack({
                        name: geneId,
                        targetId: `${this.prefix}-svg`
                    }, {
                        width: $(`#${this.prefix}-svg`).width()
                    })
                }

                let _this = this;
                this.cellbaseClient.get('feature', 'gene', geneId, 'info',
                    { assembly: this.opencgaSession.project.organism.assembly }, {})
                    .then(function (response) {
                        let gene = response.response[0].result[0];

                        let region = new Region(`${gene.chromosome}:${gene.start}-${gene.end}`);

                        let promises = [];

                        for (let i = 0; i < _this.coverageTracks.length; i++) {
                            promises.push(_this.opencgaSession.opencgaClient.alignments().lowCoverage(
                                _this._files[i].id, {
                                    region: region,
                                    study: _this.opencgaSession.study.fqn,
                                    windowSize: 1,
                                    minCoverage: threshold
                                }
                            ));

                            _this.coverageTracks[i].draw({
                                query: {
                                    region: region,
                                    study: _this.opencgaSession.study.fqn,
                                    fileId: _this._files[i].id
                                }, config: {
                                    regionOffset: _this._config.offset,
                                    lowCoverageThreshold: threshold
                                }
                            });
                        }

                        Promise.all(promises).then(function(responses) {
                            let probandIdx = -1;
                            for (let i = 0; i < _this._files.length; i++) {
                                if (_this._files[i].isProband) {
                                    probandIdx = i;
                                    break;
                                }
                            }

                            let coverageGroups = responses[probandIdx].response[0].result;

                            // Format the main response
                            for (let w = 0; w < coverageGroups.length; w++) {
                                if (UtilsNew.isUndefinedOrNull(coverageGroups[w]['region'])) {
                                    coverageGroups[w]['region'] = `${coverageGroups[w]['chromosome']}:${coverageGroups[w]['start']}-${coverageGroups[w]['end']}`;
                                    coverageGroups[w]['length'] = coverageGroups[w]['end'] - coverageGroups[w]['start'] + 1;
                                    coverageGroups[w]['stats']['average'] = coverageGroups[w]['stats']['average'].toFixed(2);
                                    coverageGroups[w]['stats']['max'] = coverageGroups[w]['stats']['max'].toFixed(2);
                                    coverageGroups[w]['stats']['min'] = coverageGroups[w]['stats']['min'].toFixed(2);
                                }
                            }

                            for (let i = 0; i < responses.length; i++) {
                                if (probandIdx === i) {
                                    continue;
                                }

                                let fileId = _this._files[i].id;

                                let responseIdx = 0;
                                for (let w = 0; w < coverageGroups.length; w++) {

                                    coverageGroups[w][fileId] = {
                                        average: -1,
                                        max: -1,
                                        min: -1,
                                        covered: 0,
                                        regions: [],
                                        values: []
                                    };

                                    for (let j = responseIdx; j < responses[i].response[0].result.length; j++) {
                                        response = responses[i].response[0].result[j];

                                        if (response.start > coverageGroups[w].end) {
                                            break;
                                        }

                                        if (response.end < coverageGroups[w].start) {
                                            responseIdx = j;
                                            continue;
                                        }

                                        if (response.start >= coverageGroups[w].start && response.end <= coverageGroups[w].end) {
                                            // Completely contained within the coverage group
                                            let covered = (response.end - response.start + 1) / (coverageGroups[w].end - coverageGroups[w].start + 1);
                                            coverageGroups[w][fileId]["covered"] += covered;
                                            coverageGroups[w][fileId]["max"] = Math.max(coverageGroups[w][fileId]["max"], response.stats.max);
                                            coverageGroups[w][fileId]["min"] = coverageGroups[w][fileId]["min"] === -1
                                                ? response.stats.min : Math.min(coverageGroups[w][fileId]["min"], response.stats.min);
                                            let region = `${response.chromosome}:${response.start}:${response.end}`;

                                            coverageGroups[w][fileId]['regions'].push(region);
                                            coverageGroups[w][fileId]['values'] = coverageGroups[w][fileId]['values'].concat(response.values);

                                        } else if (response.start < coverageGroups[w].start && response.end > coverageGroups[w].end) {
                                            // Response contains completely the coverage group
                                            coverageGroups[w][fileId]["covered"] = 1;

                                            let startIdx = coverageGroups[w].start - response.start - 1;
                                            let endIdx = startIdx + coverageGroups[w].end - coverageGroups[w].start + 1;

                                            let values = response.values.slice(startIdx, endIdx);

                                            coverageGroups[w][fileId]["max"] = _this._getMaximumValue(0, values);
                                            coverageGroups[w][fileId]["min"] = _this._getMinimumValue(-1, values);

                                            let region = `${response.chromosome}:${coverageGroups[w].start}:${coverageGroups[w].end}`;

                                            coverageGroups[w][fileId]['regions'].push(region);
                                            coverageGroups[w][fileId]['values'] = coverageGroups[w][fileId]['values'].concat(values);

                                        } else if (response.start < coverageGroups[w].start) {
                                            // Response overlaps the start of the coverageGroup
                                            let covered = (response.end - coverageGroups[w].start + 1) / (coverageGroups[w].end - coverageGroups[w].start + 1);
                                            coverageGroups[w][fileId]["covered"] += covered;

                                            let startIdx = coverageGroups[w].start - response.start - 1;
                                            let endIdx = startIdx + response.end - coverageGroups[w].start;

                                            let values = response.values.slice(startIdx, endIdx);

                                            coverageGroups[w][fileId]["max"] = _this._getMaximumValue(coverageGroups[w][fileId]["max"], values);
                                            coverageGroups[w][fileId]["min"] = _this._getMinimumValue(coverageGroups[w][fileId]["min"], values);
                                            let region = `${response.chromosome}:${coverageGroups[w].start}:${response.end}`;

                                            coverageGroups[w][fileId]['regions'].push(region);
                                            coverageGroups[w][fileId]['values'] = coverageGroups[w][fileId]['values'].concat(values);

                                        } else {
                                            // Response overlaps the end of the coverageGroup
                                            let covered = (coverageGroups[w].end - response.start + 1) / (coverageGroups[w].end - coverageGroups[w].start + 1);
                                            coverageGroups[w][fileId]["covered"] += covered;

                                            let startIdx = 0;
                                            let endIdx = coverageGroups[w].end - response.start + 1;

                                            let values = response.values.slice(startIdx, endIdx);

                                            coverageGroups[w][fileId]["max"] = _this._getMaximumValue(coverageGroups[w][fileId]["max"], values);
                                            coverageGroups[w][fileId]["min"] = _this._getMinimumValue(coverageGroups[w][fileId]["min"], values);
                                            let region = `${response.chromosome}:${response.start}:${coverageGroups[w].end}`;

                                            coverageGroups[w][fileId]['regions'].push(region);
                                            coverageGroups[w][fileId]['values'] = coverageGroups[w][fileId]['values'].concat(values);
                                        }
                                    }

                                    if (UtilsNew.isNotEmptyArray(coverageGroups[w][fileId]['values'])) {
                                        let values = 0;
                                        for (let i = 0; i < coverageGroups[w][fileId]['values'].length; i++) {
                                            values += coverageGroups[w][fileId]['values'][i];
                                        }
                                        coverageGroups[w][fileId]['average'] = values / coverageGroups[w][fileId]['values'].length;

                                        coverageGroups[w][fileId]['covered'] = coverageGroups[w][fileId]['covered'] * 100;
                                    }
                                }
                            }

                            _this._lowCoverageValues = coverageGroups;

                            // // Sort the positions
                            // positions = positions.sort();
                            //
                            // // Now we need to group all the low coverage values by files
                            // let coverageGroups = [];
                            //
                            // let lastGroup = "";
                            // let groupedResult = {
                            // };
                            // let lastPosition = positions[0] - 1;
                            //
                            // for (let i = 0; i < positions.length; i++) {
                            //     let group = "";
                            //     let numberOfFiles = 0;
                            //     for (let j = 0; j < _this._files.length; j++) {
                            //         if (UtilsNew.isNotUndefinedOrNull(result[positions[i]][_this._files[j].id])) {
                            //             group += _this._files[j].id;
                            //             numberOfFiles += 1;
                            //         }
                            //     }
                            //
                            //     // Filter out low coverages over only one of the samples if the array of files contains more than one sample
                            //     if (_this._files.length > 1 && numberOfFiles === 1) {
                            //         continue;
                            //     }
                            //
                            //     if ((lastGroup !== group || lastPosition + 1 < positions[i])) {
                            //         if (Object.entries(groupedResult).length > 0) {
                            //             coverageGroups.push(Object.assign({}, groupedResult));
                            //         }
                            //
                            //         groupedResult = {
                            //             start: positions[i]
                            //         };
                            //
                            //         lastGroup = group;
                            //     }
                            //
                            //
                            //     for (let j = 0; j < _this._files.length; j++) {
                            //         if (UtilsNew.isNotUndefinedOrNull(result[positions[i]][_this._files[j].id])) {
                            //             if (UtilsNew.isUndefinedOrNull(groupedResult[_this._files[j].id])) {
                            //                 groupedResult[_this._files[j].id] = [];
                            //             }
                            //             groupedResult[_this._files[j].id].push(result[positions[i]][_this._files[j].id]);
                            //         }
                            //     }
                            //
                            //     lastPosition = positions[i];
                            // }
                            //
                            // // Add the last group
                            // coverageGroups.push(Object.assign({}, groupedResult));
                            //
                            // // Calculate mean coverage for the groups
                            // for (let i = 0; i < coverageGroups.length; i++) {
                            //     for (let j = 0; j < _this._files.length; j++) {
                            //         if (UtilsNew.isNotUndefinedOrNull(coverageGroups[i][_this._files[j].id])) {
                            //             let sum = 0;
                            //             for (let w = 0; w < coverageGroups[i][_this._files[j].id].length; w++) {
                            //                 sum += coverageGroups[i][_this._files[j].id][w];
                            //             }
                            //
                            //             coverageGroups[i].length = coverageGroups[i][_this._files[j].id].length;
                            //             coverageGroups[i].end = coverageGroups[i].start + coverageGroups[i].length -1;
                            //             coverageGroups[i].region = `${gene.chromosome}:${coverageGroups[i].start}-${coverageGroups[i].end}`;
                            //             coverageGroups[i][_this._files[j].id] = sum / coverageGroups[i].length ;
                            //         }
                            //     }
                            // }
                            //
                            // _this._lowCoverageValues = coverageGroups;

                            // let result = {};
                            // let positions = [];
                            //
                            // for (let i = 0; i < responses.length; i++) {
                            //     for (let j = 0; j < responses[i].response[0].result.length; j++) {
                            //         response = responses[i].response[0].result[j];
                            //
                            //         for (let w = 0; w < response.values.length; w++) {
                            //             let position = response.start + w;
                            //             if (UtilsNew.isUndefinedOrNull(result[position])) {
                            //                 positions.push(position);
                            //                 result[position] = {};
                            //             }
                            //
                            //             result[position][_this._files[i].id] = response.values[w];
                            //         }
                            //     }
                            // }
                            //
                            // // Sort the positions
                            // positions = positions.sort();
                            //
                            // // Now we need to group all the low coverage values by files
                            // let coverageGroups = [];
                            //
                            // let lastGroup = "";
                            // let groupedResult = {
                            // };
                            // let lastPosition = positions[0] - 1;
                            //
                            // for (let i = 0; i < positions.length; i++) {
                            //     let group = "";
                            //     let numberOfFiles = 0;
                            //     for (let j = 0; j < _this._files.length; j++) {
                            //         if (UtilsNew.isNotUndefinedOrNull(result[positions[i]][_this._files[j].id])) {
                            //             group += _this._files[j].id;
                            //             numberOfFiles += 1;
                            //         }
                            //     }
                            //
                            //     // Filter out low coverages over only one of the samples if the array of files contains more than one sample
                            //     if (_this._files.length > 1 && numberOfFiles === 1) {
                            //         continue;
                            //     }
                            //
                            //     if ((lastGroup !== group || lastPosition + 1 < positions[i])) {
                            //         if (Object.entries(groupedResult).length > 0) {
                            //             coverageGroups.push(Object.assign({}, groupedResult));
                            //         }
                            //
                            //         groupedResult = {
                            //             start: positions[i]
                            //         };
                            //
                            //         lastGroup = group;
                            //     }
                            //
                            //
                            //     for (let j = 0; j < _this._files.length; j++) {
                            //         if (UtilsNew.isNotUndefinedOrNull(result[positions[i]][_this._files[j].id])) {
                            //             if (UtilsNew.isUndefinedOrNull(groupedResult[_this._files[j].id])) {
                            //                 groupedResult[_this._files[j].id] = [];
                            //             }
                            //             groupedResult[_this._files[j].id].push(result[positions[i]][_this._files[j].id]);
                            //         }
                            //     }
                            //
                            //     lastPosition = positions[i];
                            // }
                            //
                            // // Add the last group
                            // coverageGroups.push(Object.assign({}, groupedResult));
                            //
                            // // Calculate mean coverage for the groups
                            // for (let i = 0; i < coverageGroups.length; i++) {
                            //     for (let j = 0; j < _this._files.length; j++) {
                            //         if (UtilsNew.isNotUndefinedOrNull(coverageGroups[i][_this._files[j].id])) {
                            //             let sum = 0;
                            //             for (let w = 0; w < coverageGroups[i][_this._files[j].id].length; w++) {
                            //                 sum += coverageGroups[i][_this._files[j].id][w];
                            //             }
                            //
                            //             coverageGroups[i].length = coverageGroups[i][_this._files[j].id].length;
                            //             coverageGroups[i].end = coverageGroups[i].start + coverageGroups[i].length -1;
                            //             coverageGroups[i].region = `${gene.chromosome}:${coverageGroups[i].start}-${coverageGroups[i].end}`;
                            //             coverageGroups[i][_this._files[j].id] = sum / coverageGroups[i].length ;
                            //         }
                            //     }
                            // }
                            //
                            // _this._lowCoverageValues = coverageGroups;
                        });

                        _this.geneTrack.draw({
                            data: gene
                        });
                    });
            }

            _getMaximumValue(value, values) {
                for (let i = 0; i < values.length; i++) {
                    if (values[i] > value) {
                        value = values[i];
                    }
                }
                return value;
            }

            _getMinimumValue(value, values) {
                let myValue = value;
                if (myValue === -1) {
                    myValue = values[0];
                }
                for (let i = 0; i < values.length; i++) {
                    if (values[i] < myValue) {
                        myValue = values[i];
                    }
                }
                return myValue;
            }


            _getCoverage(coverage, file) {
                return UtilsNew.isUndefinedOrNull(coverage[file.id]) ? "-" : coverage[file.id].covered.toFixed(2);
            }

            _getAverage(coverage, file) {
                return UtilsNew.isUndefinedOrNull(coverage[file.id]) ? "-" : (coverage[file.id].average > -1 ? coverage[file.id].average.toFixed(2) : "-");
            }

            _getMax(coverage, file) {
                return UtilsNew.isUndefinedOrNull(coverage[file.id]) ? "-" : (coverage[file.id].max > -1 ? coverage[file.id].max.toFixed(2) : "-");
            }

            _getMin(coverage, file) {
                return UtilsNew.isUndefinedOrNull(coverage[file.id]) ? "-" : (coverage[file.id].min > -1 ? coverage[file.id].min.toFixed(2) : "-");
            }

            getDefaultConfig() {
                return {
                    offset: 2500,
                    sexIConMap: {
                        MALE: "fa-mars",
                        FEMALE: "fa-venus",
                        UNKNOWN: "fa-genderless"
                    }
                }
            }
        }

        customElements.define(OpencgaPanelTranscriptView.is, OpencgaPanelTranscriptView);
    </script>
</dom-module>
